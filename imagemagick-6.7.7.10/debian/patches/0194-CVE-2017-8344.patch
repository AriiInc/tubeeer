Backport of:

From 636b4d274bdb11529299fde9c5daf02ce6b40ce2 Mon Sep 17 00:00:00 2001
From: Cristy <urban-warrior@imagemagick.org>
Date: Wed, 26 Apr 2017 16:58:26 -0400
Subject: [PATCH] CVE-2017-8344

The ReadPCXImage function in pcx.c allows
attackers to cause a denial of service (memory leak) via a crafted
file.

Detect this kind of files

bug: https://github.com/ImageMagick/ImageMagick/issues/446
bug-debian: https://bugs.debian.org/862574
origin: https://github.com/ImageMagick/ImageMagick/commit/4c6289b2f39a47a430ce27b61d3e3967201e77e8
---
 coders/pcx.c | 54 ++++++++++++++++++++++++++++++++++++------------------
 1 file changed, 36 insertions(+), 18 deletions(-)

Index: imagemagick-6.7.7.10/coders/pcx.c
===================================================================
--- imagemagick-6.7.7.10.orig/coders/pcx.c	2017-05-26 08:41:18.965724565 -0400
+++ imagemagick-6.7.7.10/coders/pcx.c	2017-05-26 08:55:16.960398167 -0400
@@ -61,6 +61,8 @@
 #include "magick/static.h"
 #include "magick/string_.h"
 #include "magick/module.h"
+
+#include "magick/memory-private.h"
 
 /*
   Typedef declarations.
@@ -222,10 +224,15 @@ static inline size_t MagickMin(const siz
 static Image *ReadPCXImage(const ImageInfo *image_info,ExceptionInfo *exception)
 {
 #define ThrowPCXException(severity,tag) \
-  { \
+{ \
+  if (scanline != (unsigned char *) NULL) \
     scanline=(unsigned char *) RelinquishMagickMemory(scanline); \
-    ThrowReaderException(severity,tag); \
-  }
+  if (pcx_pixels != (unsigned char *) NULL) \
+    pcx_pixels=(unsigned char *) RelinquishMagickMemory(pcx_pixels); \
+  if (page_table != (MagickOffsetType *) NULL) \
+    page_table=(MagickOffsetType *) RelinquishMagickMemory(page_table); \
+  ThrowReaderException(severity,tag); \
+}
 
   Image
     *image;
@@ -296,6 +303,8 @@ static Image *ReadPCXImage(const ImageIn
     Determine if this a PCX file.
   */
   page_table=(MagickOffsetType *) NULL;
+  scanline=(unsigned char *) NULL;
+  pcx_pixels=(unsigned char *) NULL;
   if (LocaleCompare(image_info->magick,"DCX") == 0)
     {
       size_t
@@ -306,11 +315,11 @@ static Image *ReadPCXImage(const ImageIn
       */
       magic=ReadBlobLSBLong(image);
       if (magic != 987654321)
-        ThrowReaderException(CorruptImageError,"ImproperImageHeader");
+        ThrowPCXException(CorruptImageError,"ImproperImageHeader");
       page_table=(MagickOffsetType *) AcquireQuantumMemory(1024UL,
         sizeof(*page_table));
       if (page_table == (MagickOffsetType *) NULL)
-        ThrowReaderException(ResourceLimitError,"MemoryAllocationFailed");
+        ThrowPCXException(ResourceLimitError,"MemoryAllocationFailed");
       for (id=0; id < 1024; id++)
       {
         page_table[id]=(MagickOffsetType) ReadBlobLSBLong(image);
@@ -322,7 +331,7 @@ static Image *ReadPCXImage(const ImageIn
     {
       offset=SeekBlob(image,(MagickOffsetType) page_table[0],SEEK_SET);
       if (offset < 0)
-        ThrowReaderException(CorruptImageError,"ImproperImageHeader");
+        ThrowPCXException(CorruptImageError,"ImproperImageHeader");
     }
   count=ReadBlob(image,1,&pcx_info.identifier);
   for (id=1; id < 1024; id++)
@@ -331,8 +340,8 @@ static Image *ReadPCXImage(const ImageIn
       Verify PCX identifier.
     */
     pcx_info.version=(unsigned char) ReadBlobByte(image);
-    if ((count == 0) || (pcx_info.identifier != 0x0a))
-      ThrowReaderException(CorruptImageError,"ImproperImageHeader");
+    if ((count != 1) || (pcx_info.identifier != 0x0a))
+      ThrowPCXException(CorruptImageError,"ImproperImageHeader");
     pcx_info.encoding=(unsigned char) ReadBlobByte(image);
     pcx_info.bits_per_pixel=(unsigned char) ReadBlobByte(image);
     pcx_info.left=ReadBlobLSBShort(image);
@@ -349,16 +358,23 @@ static Image *ReadPCXImage(const ImageIn
     image->rows=(size_t) MagickAbsoluteValue((ssize_t) pcx_info.bottom-
       pcx_info.top)+1UL;
     if ((image->columns == 0) || (image->rows == 0) ||
-        (pcx_info.bits_per_pixel == 0))
-      ThrowReaderException(CorruptImageError,"ImproperImageHeader");
-    image->depth=pcx_info.bits_per_pixel <= 8 ? 8U : MAGICKCORE_QUANTUM_DEPTH;
+        ((pcx_info.bits_per_pixel != 1) && (pcx_info.bits_per_pixel != 2) &&
+         (pcx_info.bits_per_pixel != 4) && (pcx_info.bits_per_pixel != 8)))
+      ThrowPCXException(CorruptImageError,"ImproperImageHeader");
+    image->depth=pcx_info.bits_per_pixel;
     image->units=PixelsPerInchResolution;
     image->x_resolution=(double) pcx_info.horizontal_resolution;
     image->y_resolution=(double) pcx_info.vertical_resolution;
     image->colors=16;
     count=ReadBlob(image,3*image->colors,pcx_colormap);
+    if (count != (ssize_t) (3*image->colors))
+      ThrowPCXException(CorruptImageError,"ImproperImageHeader");
     pcx_info.reserved=(unsigned char) ReadBlobByte(image);
     pcx_info.planes=(unsigned char) ReadBlobByte(image);
+    if ((pcx_info.bits_per_pixel*pcx_info.planes) >= 64)
+      ThrowPCXException(CorruptImageError,"ImproperImageHeader");
+    if (pcx_info.planes == 0)
+      ThrowPCXException(CorruptImageError,"ImproperImageHeader");
     one=1;
     if ((pcx_info.bits_per_pixel != 8) || (pcx_info.planes == 1))
       if ((pcx_info.version == 3) || (pcx_info.version == 5) ||
@@ -366,7 +382,7 @@ static Image *ReadPCXImage(const ImageIn
         image->colors=(size_t) MagickMin(one << (1UL*
           (pcx_info.bits_per_pixel*pcx_info.planes)),256UL);
     if (AcquireImageColormap(image,image->colors) == MagickFalse)
-      ThrowReaderException(ResourceLimitError,"MemoryAllocationFailed");
+      ThrowPCXException(ResourceLimitError,"MemoryAllocationFailed");
     if ((pcx_info.bits_per_pixel >= 8) && (pcx_info.planes != 1))
       image->storage_class=DirectClass;
     p=pcx_colormap;
@@ -392,18 +408,22 @@ static Image *ReadPCXImage(const ImageIn
     /*
       Read image data.
     */
-    pcx_packets=(size_t) image->rows*pcx_info.bytes_per_line*
-      pcx_info.planes;
+    if (HeapOverflowSanityCheck(image->rows, (size_t) pcx_info.bytes_per_line) != MagickFalse)
+      ThrowPCXException(CorruptImageError,"ImproperImageHeader");
+    pcx_packets=(size_t) image->rows*pcx_info.bytes_per_line;
+    if (HeapOverflowSanityCheck(pcx_packets, (size_t) pcx_info.planes) != MagickFalse)
+      ThrowPCXException(CorruptImageError,"ImproperImageHeader");
+    pcx_packets=(size_t) pcx_packets*pcx_info.planes;
     if ((size_t) (pcx_info.bits_per_pixel*pcx_info.planes*image->columns) >
         (pcx_packets*8U))
-      ThrowReaderException(CorruptImageError,"ImproperImageHeader");
+      ThrowPCXException(CorruptImageError,"ImproperImageHeader");
     pcx_pixels=(unsigned char *) AcquireQuantumMemory(pcx_packets,
       sizeof(*pcx_pixels));
     scanline=(unsigned char *) AcquireQuantumMemory(MagickMax(image->columns,
       pcx_info.bytes_per_line),MagickMax(8,pcx_info.planes)*sizeof(*scanline));
     if ((pcx_pixels == (unsigned char *) NULL) ||
         (scanline == (unsigned char *) NULL))
-      ThrowReaderException(ResourceLimitError,"MemoryAllocationFailed");
+      ThrowPCXException(ResourceLimitError,"MemoryAllocationFailed");
     /*
       Uncompress image data.
     */
@@ -655,7 +675,7 @@ static Image *ReadPCXImage(const ImageIn
       break;
     offset=SeekBlob(image,(MagickOffsetType) page_table[id],SEEK_SET);
     if (offset < 0)
-      ThrowReaderException(CorruptImageError,"ImproperImageHeader");
+      ThrowPCXException(CorruptImageError,"ImproperImageHeader");
     count=ReadBlob(image,1,&pcx_info.identifier);
     if ((count != 0) && (pcx_info.identifier == 0x0a))
       {
