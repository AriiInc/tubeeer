From 65cd5c12a6cc91d4c9c9612f6204832c480e3760 Mon Sep 17 00:00:00 2001
From: Cristy <urban-warrior@imagemagick.org>
Date: Wed, 26 Apr 2017 17:32:34 -0400
Subject: [PATCH] [1/2] CVE-2017-8352

The ReadXWDImage function in xwd.c allows attackers to cause a denial of service (memory leak) via a crafted file.

bug: https://github.com/ImageMagick/ImageMagick/issues/452
bug-debian: https://bugs.debian.org/862590
origin: https://github.com/ImageMagick/ImageMagick/commit/2917930679a3543e52070668c3adb3d8c183d1f6

(cherry picked from commit 2917930679a3543e52070668c3adb3d8c183d1f6)
---
 coders/xwd.c | 15 +++++++++++++++
 1 file changed, 15 insertions(+)

Index: imagemagick-6.7.7.10/coders/xwd.c
===================================================================
--- imagemagick-6.7.7.10.orig/coders/xwd.c	2017-05-26 09:17:08.381101830 -0400
+++ imagemagick-6.7.7.10/coders/xwd.c	2017-05-26 09:17:08.377101779 -0400
@@ -333,6 +333,7 @@ static Image *ReadXWDImage(const ImageIn
         count=ReadBlob(image,sz_XWDColor,(unsigned char *) &color);
         if (count == 0)
           {
+            colors=(XColor *) RelinquishMagickMemory(colors);
             ximage=(XImage *) RelinquishMagickMemory(ximage);
             ThrowReaderException(CorruptImageError,"UnexpectedEndOfFile");
           }
@@ -363,6 +364,8 @@ static Image *ReadXWDImage(const ImageIn
   length=(size_t) ximage->bytes_per_line*ximage->height;
   if (CheckOverflowException(length,ximage->bytes_per_line,ximage->height))
     {
+      if (header.ncolors != 0)
+        colors=(XColor *) RelinquishMagickMemory(colors);
       ximage=(XImage *) RelinquishMagickMemory(ximage);
       ThrowReaderException(CorruptImageError,"ImproperImageHeader");
     }
@@ -375,6 +378,8 @@ static Image *ReadXWDImage(const ImageIn
       length*=ximage->depth;
       if (CheckOverflowException(length,extent,ximage->depth))
         {
+          if (header.ncolors != 0)
+            colors=(XColor *) RelinquishMagickMemory(colors);
           ximage=(XImage *) RelinquishMagickMemory(ximage);
           ThrowReaderException(CorruptImageError,"ImproperImageHeader");
         }
@@ -382,12 +387,16 @@ static Image *ReadXWDImage(const ImageIn
   ximage->data=(char *) AcquireQuantumMemory(length,sizeof(*ximage->data));
   if (ximage->data == (char *) NULL)
     {
+      if (header.ncolors != 0)
+        colors=(XColor *) RelinquishMagickMemory(colors);
       ximage=(XImage *) RelinquishMagickMemory(ximage);
       ThrowReaderException(ResourceLimitError,"MemoryAllocationFailed");
      }
   count=ReadBlob(image,length,(unsigned char *) ximage->data);
   if (count == 0)
     {
+      if (header.ncolors != 0)
+        colors=(XColor *) RelinquishMagickMemory(colors);
       ximage->data=DestroyString(ximage->data);
       ximage=(XImage *) RelinquishMagickMemory(ximage);
       ThrowReaderException(CorruptImageError,"UnexpectedEndOfFile");
@@ -401,6 +410,10 @@ static Image *ReadXWDImage(const ImageIn
   status=SetImageExtent(image,image->columns,image->rows);
   if (status == MagickFalse)
     {
+      if (header.ncolors != 0)
+        colors=(XColor *) RelinquishMagickMemory(colors);
+      ximage->data=DestroyString(ximage->data);
+      ximage=(XImage *) RelinquishMagickMemory(ximage);
       InheritException(exception,&image->exception);
       return(DestroyImageList(image));
     }
@@ -519,6 +532,8 @@ static Image *ReadXWDImage(const ImageIn
         */
         if (AcquireImageColormap(image,image->colors) == MagickFalse)
           {
+            if (header.ncolors != 0)
+              colors=(XColor *) RelinquishMagickMemory(colors);
             ximage->data=DestroyString(ximage->data);
             ximage=(XImage *) RelinquishMagickMemory(ximage);
             ThrowReaderException(ResourceLimitError,"MemoryAllocationFailed");
